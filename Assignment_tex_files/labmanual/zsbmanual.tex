\documentclass[10pt]{scrartcl}
\usepackage{a4wide,verbatim, moreverb, epsfig, url}
\setlength{\parindent}{0pt}
%\usepackage[T1]{fontenc}
%\usepackage[latin1]{inputenc}
\usepackage{epstopdf}
%\usepackage{auto-pst-pdf}
\usepackage{comment}
\usepackage{url}

\begin{document}

\title
%The following is year-dependent:
{Search, Actuate, and Navigate Lab course 2016-2017} 
\author
{Faculty of Science, \\University of Amsterdam}
\maketitle

\begin{quote}
  This manual describes the lab course of the first year AI course
  ``Zoeken, Sturen en Bewegen'' a.k.a. ``Search, Actuate, and
  Navigate''.

Before you ask any questions, {\textbf read through the WHOLE manual!}
\end{quote}

\vfill
\setcounter{tocdepth}{2} % makes subsubsections invisible for the toc
\tableofcontents

\clearpage


\section{Introduction}
\label{sec:Introduction}
This is the manual of the 1st year Search, Actuate, and Navigate lab
course (formerly known as the Robotics course). It gives a general
overview of the problem to be solved and its subdivision to assignments.

This manual contains a lot of information which might tend to blur your
vision of the problem at hand. This is why you have to:

\begin{enumerate}
\item Read the manual very carefully before starting the lab course.
\item Attend the lab course sessions every time where your lab
      assistants will try to guide you and provide help.
\end{enumerate}

\vspace*{.3cm}
We hope you will enjoy the lab course,
\vspace*{.3cm}
 
%\centerline{Matthijs Spaan}
%\centerline{Olaf Booij}
%\centerline{Julian Kooij}
%\centerline{Ysbrand, Nick, Casper and Tim}
%\centerline{Nick, Casper, Eva, Thomas and Eelco}
\centerline{Nick, Thomas, Boas, Pieter, Simon, Tim and Douwe}

\subsection{AI through robotic chess}

Pioneers of artificial intelligence and robotics were more than
enthusiastic and had envisioned, through rosy spectacles, a world
populated with decision-making, moving machinery. With this high
expectation, research concentrated on high levels: theories, models,
ethics, and how this impinges on other subjects. This did sometimes
appear to be esoteric; it eventually came to light that there were
indeed more down-to-earth problems yet to be solved - mechanical
structures, movement execution, optimal path-planning with obstacle
avoidance etc. It is with these latter issues that this exercise is
concerned, consciously keeping in mind throughout however, that it is
these high levels that take precedence in any `outlet'.

Chess will be the game at hand and it will stand for the essential
enigma to be solved. You are to program a {\em robot arm} enabling it to
virtually and physically carry out the solution of an arbitrary game of chess. It is a
mild but challenging and entertaining problem, and with the fine guide
of your intense, learned brain (and a computer to help it along), you
shall succeed, and furthermore be led, in time to come, towards the
creation of an intentional system\footnote{Daniel Dennett, Brainstorms,
MIT Press 1978.}. With the strong foundation in robotics that you will
acquire, we hope that you, as stars of tomorrow, will build a solid
aesthetics of method, to serve to the betterment of society. Yes! my
dear friends, Science shall march boldly forward. 
\hfill {\em (thus spake Joris van Dam)}

\subsection{The lab course}

In this lab course you will, solve chess {\bfseries endgames},
%{\bfseries plan paths} for the chess pieces, 
and {\bfseries calculate}
the required {\bfseries poses} of the robot, and so solve the problem of
a robot playing a game of chess. All other (non-trivial) tasks have
already been solved and the solutions will be provided by your lab assistants.

%Your first task is tackling a chess endgame, next is solving the path
%planning problem, third task is solving the inverse kinematics problem
%and last but not least; task four is to go, where no one has gone
%before. 

Your lab assistants will provide you with software for
separately testing your solutions to all problems. We do, however,
expect that the solutions to the 
%three 
subtasks will be submitted as a
single, working, integrated program (using our main module). This means
that you should test that your solutions to the subtasks can work
together.

While you are trying to solve the tasks you will for sure stumble upon
some awkward features (bugs) in the provided software and documentation.
Do not blame the lab assistants for this, well, just a tiny bit. We know
the software can be improved in many ways and the interfaces are not
that great, but that is partly because some parts are really old and 
some are brand new (just finished).
But actually this perfectly mirrors the problems you will be confronted
with in the ``real world'', when dealing with practical problems that
require a lot of different parts of software including drivers for old
hardware. In the last two weeks, you will encounter more of this situations.
Report them to the assistants (who perhaps already know the
feature/bug) and try to work around them. Solving these bugs is nice, but
costs a lot of time which is one thing you will lack the coming weeks.

This manual gives you a precise description of the tasks you have to
solve and provides you with the background needed to do this. First we
will explain how the software and hardware works. Read it carefully
before starting to work on the assignments.  Section~\ref{sec:Tasks}
gives the assignments you'll be working on. And finally some  general lab
instructions are given in Section~\ref{sec:Report}, ending with the ``Getting started''
(Section~\ref{subsec:GettingStarted}).

%The lab course duration is about 4 weeks. In the beginning work is done
%on the simulator. As time progresses, the groups will work for some time
%each week with the real arm ({\em which differs from the simulator!!!}).
%After three weeks, each group will give a thorough and understandable
%demonstration of the first three parts of the system, its behavior and
%moreover each group will give an explanation of the contents of its
%modules. The implementation will be discussed with the assistants.

\subsection{Other resources of information}
%The following is year-dependent:
Of course not all info you need is in this manual. Therefore one or two 
assistants will be present in the lab during the practical hours (look at
the main course page for the schedule), helping you with the tasks,
trying to help with programming, and operating the real robot. 
Your assistants for the lab course are {\bfseries Nick de Wolf}, {\bfseries Boas Kluiving}, {\bfseries Pieter Kronemeijer}, {\bfseries Simon Paul}, {\bfseries Tim Smit} and {\bfseries Douwe van der Wal}.
For questions, remarks or whatever outside the practical hours, the lab assistants can
be reached by email at:
\\\centerline{{\ttfamily N.J.G.deWolf@uva.nl}}
\\\centerline{{\ttfamily R.B.Kluiving@uva.nl}}
\\\centerline{{\ttfamily p.kronemeijer@xs4all.nl}}
\\\centerline{{\ttfamily S.Pauw@uva.nl}}
\\\centerline{{\ttfamily groeten.aan.tim@hotmail.com}}
\\\centerline{{\ttfamily douwev.dwal@live.nl}}
\\


{\textbf IMPORTANT:} When you send an email, please {\bfseries start the subject field} with the
three letter word
{\ttfamily ZSB}, such that your email can be handled appropriately by the 
email filters.

The webpage for the practical course can be found at \\
\centerline{\url{https://staff.fnwi.uva.nl/a.visser/education/ZSB/lab_course.html}}.
Check this site frequently, as it will be
updated with valuable info during the course. 
On the webpage you will also
find a link to the documentation of the Python software.

%Additional information on, e.g. the use of the software environment,
%will be given in the directory:
%
%\begin{verbatimtab}
%/opt/stud/robotics/hints
%\end{verbatimtab}

%You will be notified by e-mail if anything is added to this directory.
%Please check it at regular intervals.


\section{The programming environment}
\label{sec:programmingenvironment}

\begin{comment}
\subsection{Playchess}
\label{sec:playchess}

We will be using a simple program called {\ttfamily playchess} which does
the following (also see figure~\ref{fig:chain2}):

\begin{enumerate}
\addtolength{\itemsep}{-.1cm}
\item Call an existing chess program (GnuChess) or your endgame solver
      to play a white move.
\item Call the Java path planning module with white move.
\item Execute the Java inverse kinematics module to convert the
      Cartesian positions into values of the joint angles of the robot arm.
\item Send the joint angles to a simulator ({\ttfamily umirtxsimulator}) for
      inspection, and send them to the real robot.
\item Ask the user for a black move.
\end{enumerate}
\begin{figure}%[htbp] 
  \centerline{\epsfig{figure=images/chain2.eps,width = 0.75\textwidth}}
  % \vspace*{6cm}
  \caption{Information flow of the different components controlled by the
  {\ttfamily playchess} program. The gray-filled components are only partly
  provided and should be completed during the course. {\ttfamily board.gch}
  and {\tt *.txt} denote actual files which can be inspected and
  manipulated.}
  \label{fig:chain2}
\end{figure}
The derived programs {\ttfamily endgamerook} and {\ttfamily endgamequeen} call the
Prolog endgame solver for white moves while the user (you, or gnuchess if you
choose to) provides the black moves. This way you can test the endgame solver.
Basic path planning and inverse kinematics modules are already
provided for testing. However, during the practical course you will
develop your own modules which are hopefully as good as or better than
the ones provided. In the {\ttfamily playchess}, {\ttfamily endgamerook} and {\ttfamily
endgamequeen} programs you can decide which modules to use, the ones
provided or the ones you developed, by changing the settings.

During this lab exercise, {\ttfamily endgamequeen} will be the way to test the
king and queen versus king endgame solver. When configured to use your Prolog
code, it will execute the following command, which you can also test in a
terminal yourself:
\begin{verbatimtab}
pl -s chess.pl -g true -t startQueen
\end{verbatimtab}
The program {\ttfamily endgamerook} works similarly for the king and rook versus king 
endgame and is given as an example implementation.

\subsection{The robot simulator}

In order to check that the robot will not demolish its surroundings,
your commands will be sent to a simulator. Thus to determine
whether a particular solution to the problem is correct it is first
visualized. The simulator can be started using the program {\ttfamily
umirtxsimulator}. By running the program in the same directory as the
{\ttfamily playchess} program, the simulator will perform the black move.

When your lab assistants have confidence in your approach, they can put
the real robot arm into work using your software, via the `move
robot'-button of the simulator.
This button is the interface to a server that controls the robot. One
of the activities of the server is to calculate the `encoder counts'
based on the specified joint-angles. These encoder counts are the number
of steps the motors of the robot arm have to make to arrive at the given
joint angles. In general controllers are interesting things, but for now
of no importance to you. However, it is important that the controller is
there. It forms the interface between the joint angles and the flow of
currents to the actuators; in this case electrically powered rotary
motors.

\subsection{The chess program `GNUChess'}

This is a chess playing program which decides what move the robot should
play given the current board setting. In tasks 2 and 3 your modules have
to make sure that the move suggested by GnuChess is the one actually
played by the robot.

\end{comment}



\subsection{Component interfaces}

For the most part communication between the components inside the main program 
takes place by writing and reading files, which will be
briefly described below. The choice for this interface is partly historical,
(it allows us to interface with older software written in other programming languages (C, Java, Pascal, Prolog) 
and other operating systems (Windows 3.1, Sun Unix)) but also very practical.
While you are testing your software it is often useful to inspect 
the contents of these files and maybe even correct them to allow further testing 
(while your partner solves the bug that led to this incorrect input).

\subsubsection{Chess board representation}
\label{sec:chess-board-repr}

The chess board is represented as an ASCII file called \verb|board.gch|.
This file is constantly updated while a game is being played and is read
by the Prolog endgames implementation
% as well as the Java pathplan code
% TODO, is this the case? What about gnuchessr?
to get the most recent boardsetting.  The 8 by 8 matrix describing the
position of the pieces is the only information used by our software
components. The other values in the file such as the time control and
the score are neglected. Lower caps are the white pieces. 

%\scriptsize
\begin{minipage}{\textwidth} % enforce no page break
\begin{verbatim}
Black computer White Human 1
Castled White false Black false
TimeControl 0 Operator Time 0
White Clock 0 Moves 0
Black Clock 0 Moves 0

8 R.BQKBNR 0 0 0 0 0 0 0 0 
7 PPPPPPPP 0 0 0 0 0 0 0 0
6 ..N..... 0 0 0 0 0 0 0 0
5 ........ 0 0 0 0 0 0 0 0
4 .....p.. 0 0 0 0 0 0 0 0
3 ........ 0 0 0 0 0 0 0 0
2 ppppp.pp 0 0 0 0 0 0 0 0
1 rnbqkbnr 0 0 0 0 0 0 0 0
  abcdefgh

move  score depth  nodes  time flags capture color
\end{verbatim}
\end{minipage}
%\normalsize

\paragraph{}
You may edit this file by hand to change the position of the pieces or
replace it by another file with a different chess setup while a game is
being played. To start with a different game setting than the default,
you can add a file with the name \verb|renewboard.gch|. 
\begin{comment}
This file will
be loaded by playchess when a reset board command is send by hitting
``r''.
In \verb|/opt/prac/robotics/software4students/pl/boards| a few board settings are given on
which your implementation can be tested. These allow you to quickly and easily test your program
on a couple of different situations, but they are not cover every possible situation that your program
should be able to solve. So come up with some configurations yourself and try to find one where your
implementation performs poorly (e.g. it gets stuck in a loop or takes a lot more moves to reach
check mate than necessary).
\end{comment}

\subsubsection{Chess move}
The file \verb|move.txt| is written by your endgame solver to
communicate the chosen chess move to {\ttfamily playchess}.
%, e.g.:
%\begin{verbatim}
%a8a7
%\end{verbatim}

\begin{comment}
\subsubsection{Forcing tree}
The file \verb|forcingTree.pl| is also written by the Prolog endgame
solver (see section \ref{sec:Endgames} of this manual). It is used to store the forcing tree, for the next move (the
endgame solver is called for each chess move separately). You could also
change it while playing a game for debugging purposes.

\subsubsection{Cartesian path representation}
The Java path plan algorithm produces a list of Cartesian positions of
the robot gripper and puts these in the file \verb|positions.txt|. For
example: 
\begin{verbatim}
124.279671 313.029663 37.500000 4.188790 30.000000
124.279671 313.029663 37.500000 4.188790 0.000000
124.279671 313.029663 218.000000 4.188790 0.000000
13.937696 427.147583 218.000000 4.188790 0.000000
13.937696 427.147583 58.000000 4.188790 0.000000
\end{verbatim}
On each line a different gripper position is described using the
$x$-, $y$-, $z$-coordinate of the tip of the gripper, the roll of the
gripper and the angle between the two gripper elements respectively.
\end{comment}

\subsubsection{Joint path representation}
The \verb|joints.txt| file is quite similar to the \verb|positions.txt|
file. Your inverse kinematics algorithm writes in \verb|joints.txt|
a path as a list of configurations of the joints of the robot. For
example:
\begin{verbatim}
244.5 -29.710975377910298 100.87246341721223 -20.72525633069582 -90.0 0.0 30.0
244.5 -29.710975377910298 100.87246341721223 -20.72525633069582 -90.0 0.0 0.0
425.0 -29.710975377910298 100.87246341721223 -20.72525633069582 -90.0 0.0 0.0
425.0 -34.28883336382281 69.66192932102668 -0.5421312966905262 -90.0 0.0 0.0
\end{verbatim}
On each line a certain robot arm configuration is written. See the Java
documentation for a precise description of these values.

\section{Hardware setup}
\label{sec:Hardware}

For the path planning task it is necessary to know the position of the
chess board related to the position of the robot, and for the inverse
kinematics task you have to be aware of the possible configurations of
the robot arm.

\subsection{The chess board}
\label{setup}

\begin{figure}[htp]
  \centerline{\epsfig{figure=images/board.ps,width = \textwidth}}
  % \vspace*{6cm}
  \caption{The chess board.}
  \label{FIG_chess_board}
\end{figure}

The drawing of the board placement, see figure~\ref{FIG_chess_board}, gives the
representations of its position and some arbitrary position of the garbage
places. The $x, y, z$ position of the board is determined by the outer corner
of field h8, with the edge included. %The board is placed such that the Human
%player plays black, the Computer plays white.
% Hmmmm, after making the computer play white, the images of the board
% should be changed...

{\bfseries IMPORTANT:} Note that the coordinate system is a {\em
left}-handed system. This means, that the path planning module must
express Cartesian coordinates in this very same left handed module! 

\subsection{Robot arm configurations}

This section is related to the subtask of inverse-kinematics. We discuss
here some details of the motion of the UMI-RTX robot. This robot is
designed to work in a cylindrical workspace. Vertical movements and
rotations around the base are easily performed by controlling a single
joint. Radial movements of the wrist from and to the base involve
movements of several joints, but this is also made simple by a trick,
which is discussed in the next section.

To illustrate the difference between the performance level of the human
arm and this robot arm the following can be said: a `natural' arm of a
human has about 42 degrees of freedom. The most subtle artificial arm, for
general human use, has less than 10 degrees of freedom. The drawing,
figure~\ref{fig:hand}, specifies only 6 degrees of freedom which are the minimal
demands for an artificial fore-arm and wrist.
                    
\begin{figure}[htbp] 
  \centerline{\epsfig{figure=images/hand.ps,width = 0.3\textwidth}}
  % \vspace*{6cm}
  \caption{Degrees of freedom of a human arm.} 
  \label{fig:hand}
\end{figure}      

The UMI-RTX robot has precisely those minimal 6 degrees of freedom,
enough for finding a solution for this robot arm in the domain of chess
playing.

\subsection{Radial motion of the UMI-RTX robot}

The upper arm and lower arm have the same length: AB equals BC: % (fig. \ref{fig:arm1}).
                                   
\begin{figure}[htp]
  \centerline{\epsfig{figure=images/arm1.ps,width = 0.6\textwidth}}
  % \vspace*{3cm}
  \label{fig:arm1}
\end{figure}

This means that you can move the wrist in a straight line outwards from
the column - a radial line between the shoulder and wrist spindles - by
rotating the two parts of the arm, making sure that angle $P$ is always
half angle $Q$: % (fig. \ref{fig:arm2}).

\begin{figure}[htbp]
  \centerline{\epsfig{figure=images/arm2.ps,width = 0.4\textwidth}}
  % \vspace*{3cm}
  \label{fig:arm2}
\end{figure}
                            
The gear ratio from the shoulder motor to the upper arm is twice that of
the elbow motor to the lower arm. To move the wrist in a radial line,
both motors are driven at the same speed but in opposite directions. The
benefit of this arrangement is that the robot controller can keep track
of the position of the wrist in cylindrical coordinates very easily, by
simple calculations based on the motor encoder counts. (Encoder counts
are the units in which the movement of an rtx motor is measured).

In addition, the gripper is automatically pointing along the radial
line: % (fig.  \ref{fig:arm2}).

\begin{figure}[htbp]
  \centerline{\epsfig{figure=images/arm3.ps,width = 0.6\textwidth}}
  % \vspace*{3cm}
  \label{fig:arm3}
\end{figure}
                                   
This is achieved without needing to drive the yaw motor (angle R): the
yaw is not only \underline{coupled} to its own motor, but also
\underline{coupled} to the elbow motor! When the lower arm moves through
an angle Q, the wrist automatically moves through R, which is Q/2,
because of the 2:1 gear ratio from the combined pulley which rotates on
the elbow spindle and the wrist pulley. This behavior is by the way not
correctly produced by the simulator.

Because of this automatic compensation, it is possible with certain yaw
orientations for the wrist to hit its end-stops when driving the arm
radially in and out.

\section{Tasks}
\label{sec:Tasks}
\subsection{Task 1: SimpleChess}
\label{sec:SimpleChess}

\section*{Introduction}
In this assignment, you will implement a chess engine for a simplified version of chess. You will be using the minimax algorithm to implement the chess engine. Minimax is an algorithm that maximizes the win in situations where an ideal opponent plays against you.  

\section*{SimpleChess}
Chess itself contains many different and special rules, which can take some time to implement. In order to make this assignment more containable and less tedious to implement, we will be looking at a simplified kind of chess game called SimpleChess. In SimpleChess, the only chess pieces used are the king, rook and pawn. While the king can still reach any adjacent square (even diagonal) and the rook can still reach all horizontal and vertical squares, the pawn can always only move one place forward.

You may assume the following simplifications:
\begin{itemize}
    \item The only pieces on the board are the king, pawn and rook.
    \item A pawn cannot promote when it reaches the other side.
    \item A pawn can only move one piece forward at a time (even the first turn).
    \item There is no checkmate; the game is over when one of the kings is hit.
    \item You do not need to worry about stalemate until later in the assignment
\end{itemize}

\section*{The framework}
\subsection*{Helper functions}
The static classes \texttt{Material} and \texttt{Side} are just used to provide enums for board pieces and the player turn, so you can refer to a rook with \texttt{Material.Rook} instead of a string/char and refer to the white player with \texttt{Side.White}. A chess piece is then represented as an \texttt{Piece} object with two properties: side and material.

The helper functions \texttt{to\_coordinate} and \texttt{to\_notation} when converting a position in x,y-notation (e.g. (2,5)) to a board coordinate in chess notoation (e.g. "c3") and vice versa. Note: (0,0) corresponds to "a8".

\subsection*{Classes}
A single board state is specified by the \texttt{ChessBoard} class. The \texttt{ChessBoard} class contains two variables. The \texttt{turn} variable specifies whether the white or black player is on turn. The \texttt{board\_matrix} variable contains an 8 by 8 2d-array array with at each cell either \texttt{None} if no chess piece is present at that position or the \texttt{Piece} object specifying the chess piece that is present at that position. You can use getter function \texttt{get\_boardpiece} and setter function \texttt{set\_boardpiece} to retrieve and set a chess piece at a specified position.

Apart from representing a board state, the \texttt{ChessBoard} class is also responsible for reading a board configuration from input (\texttt{load\_from\_input})and printing itself (\texttt{\_\_str\_\_}). Lastly, it also contains the \texttt{legal\_moves} function, which should return all the possible moves for the current board state. You will need to implement this function yourself.

The \texttt{ChessComputer} class provides functions to calculate the best computer move using minimax or alphabeta. You will need to implement both functions. The function \texttt{evaluate\_board} should give a score to each board configuation as to how favourable this configuration is for the white or black player.

Lastly, the \texttt{ChessGame} class contains functionality for playing the game in the command line and reads input from the user. This class will automatically load the configuration in \texttt{chess.chb} in the same directory. If you would like to open another board configuration, you can specify this as a command line argument (i.e. \texttt{python chessgame.py board\_configurations/capture\_king1.chb}). You will not need to make changes to this class.


\section*{The assignment}
The first function we need to implement when writing the chess engine is a function that returns all the legal moves of the rooks, pawns and king that are possible given a certain board configuation. To this end, you will need to implement \texttt{legal\_moves} in the \texttt{ChessBoard} class. Make sure you test this functionality before continuing with the next part, since this function will be used in later parts of the assignment.


Secondly, we need to assign a score to every board position. We will do this in the \texttt{evaluate\_board} function in the \texttt{ChessEngine} class. A simple way to give a score to a board configuration is to give a score for each pawn, rook and king white has on the board and subtract the material that black has on the board. This way, a board configuration in which a rook of the opponent is captured will have a higher score. Make sure you form the score in such a way that a rook has a higher score when captured than multiple pawns and capturing the king even higher (since then the game is won).
Besides counting material, you would also like to prefer strategies for capturing material that take fewer turns than long strategies (e.g. if you can capture a king in 2 turns, you should not take 4 turns to do so). You can use the \texttt{depth\_left} variable for this.

You are free to implement this scoring function any way you like, but for full credits you do need to make sure that the minimax algorithm will perform optimally on all the board configurations that are included with the assignment.

If you finished the scoring function and the legal moves function, you have essentially all the basics you need to implement the minimax algorithm. We are going to implement a depth-bounded minimax algorithm.  Use \texttt{legal\_moves} to enumerate all the moves possible, \texttt{make\_move} to execute this move and \texttt{evaluate\_board} to give a score to a board position after we have reached the maximum depth.

Once you have the minimax algorithm, you can implement the alpha-beta optimization in \texttt{alpha\_beta}.

The different parts of the assignment are weighed as follows:
\begin{itemize}
    \item (3 pt) Implement \texttt{legal\_moves} in the \texttt{ChessBoard} class
    \item (2 pt) Implement \texttt{evaluate\_board} in the \texttt{ChessEngine} class
        \begin{itemize}
            \item For full credits, the chess engine should handle all of the board configurations attached in the assignment well.
        \end{itemize}
    \item (2 pt) Implement \texttt{minimax} in the \texttt{ChessEngine} class
    \item (1 pt) Implement \texttt{alphabeta} in the \texttt{ChessEngine} class
    \item (2 pt) Implement two of the following enhancements:
        \begin{itemize}           
            \item Make the chess engine able to prevent stalemate situations
            \item Include at minimum two other chess pieces, such as the queen and the knight
        \end{itemize}
\end{itemize}

\subsection{Task 2: A chess playing robot arm}
\label{sec:Inversekinematics}

\section*{Introduction}

In this assignment you will be implementing inverse kinematics in a VPython simulation in order to make a robot arm play chess. There are three parts to this assigment:
\begin{itemize}
    \item Cartesian Coordinate conversion
    \item Inverse kinematics
    \item High path planning    
\end{itemize}
The high path planning is a series of instructions the robot arm will need to follow in order to move a piece. The inverse kinematics part will tell the robot exactly what angles the individual arm joints need to have so it will be at a desired location. And the coordinate conversion means that you translate a board position, e.g. "a1", to a real world coordinate. You can determine yourself in what order you want to complete these modules as they work independently. However, we suggest starting with high path planning and coordinate conversion. These are the easier components, so it will allow you to familiarize yourself with python again.

\section*{VPython simulator}
The simulator uses ``Classic" VPython 6 in combination with Python 2.7, and the version we use works by default on Windows and not on Linux (yes, we managed to find a Python package that does not work on Linux by default...)

\subsection*{Installation}
\subsubsection*{Windows}
For more download instructions, you can refer to \url{http://www.vpython.org/contents/download_windows.html}.

Check if you have Python 2 installed on your computer, at the following location:

\begin{verbatim}
    C:\Python27
\end{verbatim}
If this is the case you can download either the 32-bit or the 64-bit VPython depending on what python version you have installed. To check what version you have installed use the command:

\begin{verbatim}
    C:\Python27\python.exe
\end{verbatim}
And you should see a line of text showing you your version details, including the bits. If you have Anaconda installed for Python 2, you can use this command instead:

\begin{verbatim}
    conda install -c https://conda.binstar.org/mwcraig vpython
\end{verbatim}
After you install the correct VPython version, it should work right away.
\subsubsection*{Linux}
For more download instructions, you can refer to \url{http://www.vpython.org/contents/download_linux.html}.
Linux requires slightly more work and requires you to use Wine (basically a bit of windows inside Linux). The installation instructions of Wine, can be found here: \url{https://wiki.winehq.org/Ubuntu}. Depending on the version you installed, pick the correct files from the download\_linux link, and place them in the correct folders (once again check the bit versions that you use) and follow the \emph{Installing VPython 6 under Wine} instructions on the web page.

\subsection*{What is provided?}

In order for you to find the correct parameters for the robot, without having to go measure it yourself, and probably end up making mistakes, we provide you with the Denavit-Hartenberg convention for robot joint parameters of the simplified UMI in Table \ref{tab:denavit}.

\begin{table}[h!]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|} \hline
        Joint$_i$ & $\Theta_i$ & $\alpha_i$ & $a_i$ & $d_i$ & Joint range \\ \hline
        riser/zed & 90.0 & 0.0 & 67.5 & 1082.0 & 0.0 - 925.0 \\ \hline
        shoulder & 0.0 & 0.0 & 253.5 & 95.0 & -90.0 - 90.0 \\ \hline
        elbow & 0.0 & 0.0 & 253.5 & 80.0 & 180.0 - 110.0 \\ \hline
        wrist & 0.0 & -90.0 & 0.0 & 90.0 & -110.0 - 110.0 \\ \hline
        gripper & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 - 50.0 \\ \hline
    \end{tabular}
    \caption{The Denavit Hartenberg notation of the simplified UMI robot arm. The $d_i$ of the wrist includes the $d_i$ of the gripper. Distances are given in mm (\textbf{the simulator uses meters})}
    \label{tab:denavit}
\end{table}

The simulator that will be provided to you consists of the following files:
\begin{itemize}
    \item \textbf{umi\_chessboard.py} - Contains the representation of the chessboard and the pieces. Also contains functions that have to do with the translation and rotation of the board.
    \item \textbf{umi\_common} - Contains some functions that are used across all the files, also included the functions for file interactions.
    \item \textbf{umi\_parameters} - This file contain all the parameters of the robot arm, but it is your task to retrieve this information, and add it correctly.
    \item \textbf{umi\_simulation} - Contains the simulator for the robot arm, and all the functions that have to do with the visualizations. This file is also the main function to call, if you want to run the program. The sliders work per default, as long as you have the correct parameters.
    \item \textbf{umi\_student\_functions} - Empty shells of functions for you to fill, such that all functionality works correctly.
\end{itemize}

\subsection*{High path - 2 points}
In order to play chess, the robot arm needs to be able to move a chess piece from one location to another. To achieve this the robot arm will need to follow a series of instructions:
\begin{enumerate}
\item Open gripper
\item Move to safe height over piece
\item Move to low height over piece
\item Move to piece height
\item Close gripper
\item Move to safe height over piece
\item Move to safe height over new position
\item Move to low height over new position
\item Move to piece height
\item Open gripper
\item Move to safe height
\end{enumerate}
Where safe height is an arbitrary height above a board location where it is impossible to for the robot arm to interact with the pieces. Low height is right above the piece and piece height is the height where the robot arm is able to actually grab the piece. These instructions can be implemented in the \textbf{high\_path(chessboard, from\_location, to\_location)} function

In addition, very similar to the above function, you also have a move\_to\_garbage function. With the difference that it now drops the pieces on a garbage pile outside of the board. You can choose different ways to solve this problem e.g. place the in a nice row next to the board, or just toss them in your imaginary box. These instructions can be implemented in the \textbf{move\_to\_garbage(chessboard, from\_location, to\_location)} function

\subsection*{Cartesian Coordinate Conversion - 4 points}
Because the UMI robot arm is blind, it is difficult for him to determine what to do if you tell it to move a piece from "a1" to "a3". After all, it can not see the chessboard. Hence, you will write a function to help him out, by writing the function that returns a (x,y,z) tuple, when given a position in the form $<$letter$><$digit$>$ e.g. "a1". For this you will use the rotation and translation of the board, as well as the position of the piece. The rotation point of the chessboard is next to the position "h8". These instructions can be implemented in the \textbf{board\_position\_to\_cartesian(chessboard, position)} function.

\subsection*{Inverse kinematics - 4 points}
Solve the inverse kinematics problem for the robot arm: "Given a point on the board and a height, what are the joint angles needed for the robot arm to reach this point?". Keep in mind that there is no right answer for this. Inverse kinematics generally does not have one solution as there are multiple ways to reach the same position. This means that you can implement movement that you think is best as long as it works within the simulator. Inverse kinematics can be implemented in the \textbf{apply\_inverse\_kinematics(x, y, z, gripper)}


\subsection{Task 3: Go, where no one has gone before}
\label{sec:Experiment}

{\textit This section is intentionally left blank, content to be provided by you. 
We expect a research proposal with your plans in the third week.}

The only requirement is that you come up with an idea of a thing 'never done before' in this course.

An overview of things that were already tried:
\begin{itemize}
\item \url{https://staff.fnwi.uva.nl/a.visser/education/ZSB/2016/Experiment/}
\item $\cdots$
\item \url{https://staff.fnwi.uva.nl/a.visser/education/ZSB/2004/Experiment2004/}
\end{itemize}

\section{General lab course instructions}
\label{sec:Report}
\subsection{General instructions}
During the first two weeks you will be working in {\em pairs}.
For the secnond two weeks you will be working in a {\em quartet}.
By making you work in groups we aim to give you an idea of how it
is to work in a team. If there are any unsolvable organizational
difficulties, troubles, hitches, impasses etcetera, do not act too late
and inform your lab assistants at an early stage before everything gets
out of hand. We would like to prevent students from getting lost. So
definitely do not hesitate to inform us that there is some problem.

For the first two tasks you will hand in your software and an accompanying readme per
pair. 
%And at the end of se week you will demonstrate all your code on the robot to one of the lab assistants. 

For the last two weeks we will expect a more extensive research proposal and technical report.

\begin{comment}
\subsection{Writing reports}
The reports you hand in should be about 2 to 3 pages, written in English or Dutch 
and contain (at least) the following topics: 
\begin{itemize}
%\addtolength{\itemsep}{-.05cm}
  \item explain the problem at hand
  \item discuss possible solutions you considered
  \item why did you choose the solution you implemented?
  \item how did you test your program?
  \item conclude with any suggestions for improving your algorithm or code
\end{itemize}

Although the lab report in not quite like a small research paper, it is still supposed to
be an academic report of your work, rather than an informal description of how you spend your week.\\

\noindent So do:
\begin{itemize}
\item Clearly structure your report
\item Explain your method formally
\item Report your experiments and results precisely
\item Write in correct academic English or Dutch
\end{itemize}
Don't:
\begin{itemize}
\item Give a day to day overview of your activities
\item Talk about debugging or how much time you spend implementing a particular feature
\item Mention if a TA or fellow student suggested something to you. Just explain what you did and why (which should be a better reason than just someone telling you to)
\end{itemize}
\end{comment}

Details how to write a research proposal and technical report can be found at the \textit{Practicum Academische Vaardigheden}-website:
\begin{itemize}
\item \url{http://practicumav.nl/onderzoeken/onderzoeksvoorstel.html}
\item \url{http://practicumav.nl/onderzoeken/rapport.html}
\end{itemize}

Upload your reports in a printable format, that is: PDF (so
no tex-code, plain text-files or Word-files).
%Instructions on writing reports can also be found on the lab course website.

\subsection{Writing software}
Implementation of your ideas into code is only half of the job to be
done for this lab course. Inside your source-files we want the
following information:

\begin{description}
\addtolength{\itemsep}{-.05cm}
\item a header:   
\addtolength{\itemsep}{-.05cm}
  \begin{itemize}
    \addtolength{\itemsep}{-.05cm}
    \item the filename
    \item a short description what's in the file
    \item the names, registration-numbers and login-names of both partners
    \item the id of your group.
    \item the current date
  \end{itemize}
\item comments:   
  \begin{itemize}
    \addtolength{\itemsep}{-.05cm}
    \item on a tactical level: to indicate where dirty tricks are performed
    \item on a strategic level: to explain what was your intention
      for a piece of code
  \end{itemize}
\item self-explaining function- and variable-names:   
  \begin{itemize}
    \addtolength{\itemsep}{-.05cm}
    \item the most important issue is to be consistent
    \item don't mix Nederlands and English
  \end{itemize}
\item structure:   
  \begin{itemize}
    \addtolength{\itemsep}{-.05cm}
    \item make use of empty space to make your program readable
    \item order your functions in a logical way
  \end{itemize}
\item error reports:   
  \begin{itemize}
    \addtolength{\itemsep}{-.05cm}
    \item describe how the software was tested
    \item make sure that both programmer and user can understand
      what went wrong
  \end{itemize}
\end{description}

%Instructions on writing software, and commenting examples, can also be found on the lab course website.

%\subsection{Writing software}
%
%Throughout the manual, you were pressed to strive for modularity in the
%set up of your program. This is not because the lab assistants get a
%kick out of modularity; it will facilitate to great extent the
%development and understandability of your program. With a modular set-up
%of your program, each scientist can implement a separate module
%concurrently. You will undoubtedly notice we are pressed with time.
%Don't jump to programming and stick to the 40-20-40 design-build-test
%rule. Cutting down on the first forty will result in an uneven growth of
%the last forty and an uneven fall in your final grade.
%
%
%Of course, you all have some brilliant ideas on how the program could be
%improved if we'd just have another interface. Most of you are probably
%right and some of you may even be brilliant. However, we don't have
%time. There are only a few weeks available to finish your program. The
%interface is not the best possible, but it works and it allows us to use
%older software for ``stub'' procedures. Just stick to the interface and
%show your brilliance in the way you handle your assigned task.
%
%Rather we would prefer that you'd extend your program (if time permits!)
%to a less structured working environment, i.e. develop a more robust
%system. What if the board data is inaccurate? What if the garbage place
%seems full? What if there is no inverse kinematics solution: does the
%program crash or call for another move?

\subsection{Testing your software on the robot}
If you tested your code on the simulator and you are (very) confident
that it works correctly and does not, for example, press a chess piece
through the chess-board, then you may want to test it on the real robot.
However there is only one robot and limited time available.
When an assistant is confident in your implementation, he could sent you to the robolab
to test it on the actual UMI-RTX  the robot. In that case, send
all your code to the lab assistant in the following manner.

Compose an email with the subject reading {\ttfamily\small ZSB Your
Name} and attach your code, see Section~\ref{subsec:Howtosendcode} how to append
your code. Specify your names and student-ids in the mail.

%You can test your modules stand alone using the main program and stub
%modules made available by your assistants. Let it be noted that we
%expect that fully integrated routines are submitted at the end of the
%course.

\subsection{How to send your code}
\label{subsec:Howtosendcode}
The code should be send as one {\em tar} file attached to an email to the assistant. To create a tar file do the following.
\begin{itemize}
  \item Open a terminal.
  \item Go to the directory with your code ({\ttfamily\small cd \~{}/zsb/}).
  \item make a tarball of it by executing {\ttfamily\small tar -cvf YourName\_Code.tar .} \# don't forget the dot
  \item Attach the tarball to your mail.
\end{itemize}
If you do not understand how to work with a terminal or you do not want
to learn it (sigh...), you can also make a zip file of your code with
your favorite gui zip-program and attach the zip file.

\subsection{Grading}
Each task as well as the final demonstration will be graded. 
For grading the tasks we will not only look at the approach that was
chosen to solve the problems but also the reasoning behind these
choices. Explain in your report why you implemented algorithm
$B$ and not algorithm $A$, and show that you understand the pros and
cons of the different methods. 
Also the readability of the report and the code will be taken into
account.
Your lab course assistants will try their best to finish evaluating your
reports the week after they were handed in. So the feedback can be used
to improve the next report.

The demonstration will really be a crash-test for your system. In a few
minutes you will have to show that your software works on a couple of
tasks. Be sure to have a stable final version, because there will be no
time for in-between hacking.

\begin{comment}
\subsection{Getting started}
\label{subsec:GettingStarted}


If you are working on your own laptop, you should first reach the Linux-server dedicated for students. 

This can be done in two steps:

\begin{itemize}
\item Start a secure connection with VPN\footnote{See for instructions \url{https://informatica-byod.innovatievooronderwijs.nl/index.php/Hoofdpagina}}.
\item Make a terminal connection with the command \texttt{ssh username@acheron.fnwi.uva.nl}.
\end{itemize}

If you are one of the Linux-machines at the UvA-campus, you only have to open a terminal window.

The first time you start working you should setup your environment.
This section assumes that you are using the {\tt bash} shell,
     which is the default on student accounts nowadays.

%To setup the environment, you need to enable certain software packages such that
%you can run the required programs. Software packages are managed by the {\tt
%softpkg} program (e.g. you can use {\tt softpkg -l} to list available packages).
%Setting up the software packages for this course is done in two steps.
%First, you need to define where some additional packages for this lab course are
%located in the system.
%This will be done by extending the {\tt PACKAGEPATH} environment variable on your account.
%Second, you need to tell {\tt softpkg} {\it which} packages you want enabled on your
%account.
In order to use the provided software you will need to make sure your environment variables include the location of the required files and packages.
You can do this by following the steps listed below.
\\

Assuming you are using the bash shell, you will need to update your {\ttfamily\small
\~{}/.bashrc} (i.e. ``bash resource file'').
If you do not know which bash configuration files are set on your account,
   list them with:
\begin{verbatimtab}
ls -la ~/.bash*
\end{verbatimtab}
The list will probably include {\tt .bash\_history}, and may or may not
include {\tt .bashrc} and other configuration files.

\paragraph{Step 1a}
Step 1a
If you already have a ~/.bashrc file, edit it and add
directly after any existing ``{\tt export PATH=...}'' line
the following:
\begin{verbatimtab}
PATH=$PATH:/opt/prac/robotics/bin
export PATH
\end{verbatimtab}
and directly after any existing ``{\tt export CLASSPATH=...}'' line
the following: 
\begin{verbatimtab}
CLASSPATH=$CLASSPATH:/opt/prac/robotics/class
export CLASSPATH
\end{verbatimtab}
%If you already have a {\tt \~{}/.bashrc} file, edit it and add
%directly after any existing ``{\tt export PACKAGEPATH=...}'' line
%the following:
%\begin{verbatimtab}
%export PACKAGEPATH=/opt/prac/robotics/pkg:$PACKAGEPATH
%\end{verbatimtab}
%Now softpkg can find the additional packages for the robotics course.

\paragraph{Step 1b}
If you do not have a {\tt \~{}/.bashrc} file yet, we will provide you with an already
correctly configured version. Copy it using the following command:
\begin{verbatimtab}
cp /opt/prac/robotics/software4students/bashrc ~/.bashrc
\end{verbatimtab}
Note that the target file should be called {\tt .bashrc}, so starting with a `.'!
Additionally you need to copy the following file too if it does not exist in
your home directory yet:
\begin{verbatimtab}
cp /opt/prac/robotics/software4students/bash_profile ~/.bash_profile
\end{verbatimtab}


%\paragraph{Step 2}
%Next, tell softpkg which software packages should be enabled on your account.
%Edit your {\ttfamily\small \~{}/.pkgrc} (i.e. ``package resource file'') file
%and add these two lines at the end:
%\begin{verbatimtab}
%robotics
%jdk
%swiprolog-5.4.7
%\end{verbatimtab}
%and remove or comment out any lines with just {\ttfamily\small swiprolog}.

% Log yourself out and back in again.
Close any open terminal window, and open a new one.
This will start a new bash session, with the correct packages enabled.
Now you're ready to start the
simulator of the robot arm and your java {\ttfamily\small CLASSPATH} should be set.

%\paragraph{Step 3}
\paragraph{Step 2}
Test if your account is configured correctly by running
\begin{verbatimtab}
umirtxsimulator
\end{verbatimtab}
Typing just {\tt umi} and pressing the TAB key should automagically complete the
command.

You should now create a directory for all your work in the lab course.
Type in the shell for example:
\begin{verbatimtab}
cd
mkdir zsb
cd zsb
\end{verbatimtab}

\subsubsection*{Downloading the software4students}

If you like to repeat those steps on your own laptop, the software4students can also be downloaded from \url{https://staff.fnwi.uva.nl/a.visser/education/ZSB/software4students.tgz}. The binaries are also available, but only will work in a 64-bits Linux environment ( \url{https://staff.fnwi.uva.nl/a.visser/education/ZSB/binary4students.tgz}).  The distribution of those binaries to your own laptop is not tested, so if you encounter problems try to make a clear error-report, which will allow us to make this distribution byod-proof.
 
\subsubsection*{Tip for KDE}

In this lab course, you will mostly be working in the terminal (running bash).
However, most people login into a graphical desktop environment to run and manage
terminal, editor and browser windows.
For new student accounts this environment is KDE, which has as default behavior
that the window focus follows the mouse, i.e. you always type in the window
currently under the mouse pointer.
If you prefer that the window focus is set by clicking on a
window, you can change this behavior by following these instructions:

From the `start' button at the button left of the screen, open `Control
Center'. In the control center, select `Desktop', then `Window Behavior'.
You now see an option for the focus policy, which states {\textit Focus Follows Mouse}.
Change this to {\textit Click to Focus} and click `Apply'.

\end{comment}

%\subsubsection{The grading}
%The grading of the prolog assignment will be based on:
%
%\begin{description}
%  \item[Efficiency in terms of the endgame.] The smarter your advice
%        language, the less moves it needs in certain situations to give
%        checkmate to the opponent.
%
%  \item[Readability code.] The code you create should be readable. That
%        means a lot of \emph{comments}, and \emph{intuitive} variable
%        names.  One cannot stress this enough, but do this \emph{during}
%        the creation of your code and \emph{not} afterwards. This being
%        said, we do not have the illusion that you will actually do this
%        (most people don't, but it will eventually backfire: good
%        commented code is far easier to debug).
%
%  \item[Efficiency in terms of computation time.] This is the least
%        important of the things mentioned. Only do this when you are
%        certain of your programming skills. Note that usually there is a
%        trade-off between readability and efficiency, so document such
%        code well.
%\end{description}


\section*{Acknowledgments}

Toto van Inge and George den Boer undertook the painstakingly effort of
setting up the entire practical course and also wrote the first version
of this manual.  Their successors were Arnoud Visser and Joris van Dam.
The manual was 
subsequently modified by Gerben Venekamp, Daan van
Schaijk, Nikos Massios, Paul Ruinard, Matthijs Spaan,
Olaf Booij, Julian Kooij, Tim van Rossum, Elise Koster, Michael Cabot, 
Robrecht Jurriaans, Toto van Inge, Nick de Wolf and Boas Kluiving.

\end{document}

% localwords:  arnoud visser joris ruinard massios nikos mathijs kattenberg uva
% localwords:  mtjspaan nl vkattenb webpage practicum www epsfig scil readme
% localwords:  moreverb highpath lowpath robotica mkdir javac java chessboard
% localwords:  movetogarbage spaan bratko prolog bratko's
